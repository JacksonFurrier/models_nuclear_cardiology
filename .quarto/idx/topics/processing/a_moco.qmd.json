{"title":"Motion phenomena and correction in SPECT","markdown":{"yaml":{"title":"Motion phenomena and correction in SPECT"},"headingText":"Motion effect on frames","containsRefs":false,"markdown":"\n\nOne of the big problems during acquisiton of MPI SPECT is the [motion phenomena](https://eanm.org/wp-content/uploads/2024/06/EANM_2014_Myocardial_Tech_Guide.pdf), which can result in acquisition readback, misdiagnosis or the evaluation of invasive procedures on patients. \n\n\n```{python}\n#| echo : false\n# Loading the data\nimport plotly.graph_objects as go\nimport numpy as np\nimport nrrd\n\nnum_moco_proj = 64\n\nproj_data_moco_par, moco_par_header = nrrd.read('../../data/class_webpage_projs_motion_par.nrrd')\n```\n\n\n```{python}\n#| echo : false\nfrom IPython.display import HTML\nfrom numpy import random\nfrom matplotlib import animation\nimport matplotlib.pyplot as plt\n```\n\n```{python}\n#| title: Projection frames with motion phenomena\n#| echo : false\n%%capture\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\nims = []\nfor i in range(num_moco_proj):\n    im = ax.imshow(proj_data_moco_par[i], animated=True)\n    im.axes.get_xaxis().set_visible(False)\n    im.axes.get_yaxis().set_visible(False)\n    ims.append([im])\n\nani_par_motion = animation.ArtistAnimation(fig, ims, interval=50, blit=True,\n                                repeat_delay=1000)\n```\n\nEffect of motion on the projection frames\n```{python}\n#| echo : false\nHTML(ani_par_motion.to_jshtml())\n```\n\n\n## Motion effect on the reconstructed volume\nAfter reconstructing $u$ with the adjugate forward (backward) operator $F^{*}$, one arrives at a volume with incorrect cardiac activities and shape variations.\n\n\n```{.python include=\"../../src/tools/recon/projector.py\"}\n# Running reconstruction and all kinds of magic\n```\n\n```{python}\n#| echo: false\n%run \"../../src/tools/recon/projector.py\"\n```\n\n```{python}\n#| echo : false\nbprojector = backward_projector()\nlv_volume = bprojector(proj_data_moco_par)\n```\n\n```{python}\n#| title: Reconstructed volume from projection frames with motion effect\n#| echo : false\n%%capture\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\nims = []\nfor i in range(num_moco_proj):\n    im = ax.imshow(lv_volume[i], animated=True)\n    im.axes.get_xaxis().set_visible(False)\n    im.axes.get_yaxis().set_visible(False)\n    ims.append([im])\n\nani_par_motion_vol = animation.ArtistAnimation(fig, ims, interval=50, blit=True, repeat_delay=1000)\n```\n\n```{python}\n#| echo : false\nHTML(ani_par_motion_vol.to_jshtml())\n```\n\n## Algorithms to detect and correct motion\n### 1. Optical flow\n1. Classical approach \nThis methodology is based on the assumption of *brightness constancy* , which means that the intensity of a point between consecutive frames remains the same. This can be formalized as follows\n$$I(x, y, t) - I(x + u, y + v, t + 1) = 0, $$\nwhere $w = (u, v)$ is the displacement vector between the frames. This leads to an underdetermined system of equations, needing further constraints to overcome the [aperture problem](https://en.wikipedia.org/wiki/Motion_perception#The_aperture_problem).\n\n2. Regularized models\nThere can be various techniques to regularize the aperture problem, where most naturally the *smoothness* constraint can be posed, where one can optimize the following [functional](https://en.wikipedia.org/wiki/Functional_(mathematics))\n$$E = \\iint_{\\Omega} \\Psi(I(x + u, y + v, t + 1) - I(x, y, t)) + \\alpha \\Psi(|\\nabla u|) + \\alpha \\Psi(|\\nabla v|) dx dy,$$\nwhere $\\Omega$ is the extent of the entire image $I(x, y, t)$, $\\nabla$ is the nabla (gradient) operator, $\\alpha$ is a constant and $\\Psi(.)$ is a loss function. One approach to solve this optimization problem to use the [calculus of variations](https://en.wikipedia.org/wiki/Calculus_of_variations) to compute the first variation and as a result get a necessary condition for the extremum. The *BCC* can be approximated by the [Taylor series](https://en.wikipedia.org/wiki/Taylor_series) expansion, more specifically \n$$\\frac{\\delta I}{\\delta x}u + \\frac{\\delta I}{\\delta y}v + \\frac{\\delta I}{\\delta t} = 0$$, wherewith the optimization problem can be rewritten as \n$$E = \\iint_{\\Omega} \\Psi(I_{x}u + I_{y}v + I_{t}) + \\alpha \\Psi(|\\nabla u|) + \\alpha \\Psi(|\\nabla v|) dx dy.$$\n\n3. Parametric models\nInstead of posing regularity constraints point-by-point on the pixels of the projection frames, one can group pixels into regions and estimate the motion of the regions themselves. This way one assumes that the motion can be estimated by a set of parameters, therefore the model looks as follows\n$$\\hat{\\alpha}= \\underset{\\alpha}{\\operatorname{argmin}} \\sum_{(x,y)\\in R} g(x, y) \\rho(x, y, I_{1}, I_{2}, u_{\\alpha}, v_{\\alpha}),$$\nwhere $\\alpha$ is the set of parameters determining the motion of the region $R()$, data cost term is $\\rho()$, $g()$ is the weighting funtion that determines the influence of pixel $(x, y)$ on the total cost, where $I_{1}$ and $I_{2}$ are the consecutive frames.\n\n### 2. Metamorphosis\n\n### 3. Correction during reconstruction","srcMarkdownNoYaml":"\n\nOne of the big problems during acquisiton of MPI SPECT is the [motion phenomena](https://eanm.org/wp-content/uploads/2024/06/EANM_2014_Myocardial_Tech_Guide.pdf), which can result in acquisition readback, misdiagnosis or the evaluation of invasive procedures on patients. \n\n## Motion effect on frames\n\n```{python}\n#| echo : false\n# Loading the data\nimport plotly.graph_objects as go\nimport numpy as np\nimport nrrd\n\nnum_moco_proj = 64\n\nproj_data_moco_par, moco_par_header = nrrd.read('../../data/class_webpage_projs_motion_par.nrrd')\n```\n\n\n```{python}\n#| echo : false\nfrom IPython.display import HTML\nfrom numpy import random\nfrom matplotlib import animation\nimport matplotlib.pyplot as plt\n```\n\n```{python}\n#| title: Projection frames with motion phenomena\n#| echo : false\n%%capture\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\nims = []\nfor i in range(num_moco_proj):\n    im = ax.imshow(proj_data_moco_par[i], animated=True)\n    im.axes.get_xaxis().set_visible(False)\n    im.axes.get_yaxis().set_visible(False)\n    ims.append([im])\n\nani_par_motion = animation.ArtistAnimation(fig, ims, interval=50, blit=True,\n                                repeat_delay=1000)\n```\n\nEffect of motion on the projection frames\n```{python}\n#| echo : false\nHTML(ani_par_motion.to_jshtml())\n```\n\n\n## Motion effect on the reconstructed volume\nAfter reconstructing $u$ with the adjugate forward (backward) operator $F^{*}$, one arrives at a volume with incorrect cardiac activities and shape variations.\n\n\n```{.python include=\"../../src/tools/recon/projector.py\"}\n# Running reconstruction and all kinds of magic\n```\n\n```{python}\n#| echo: false\n%run \"../../src/tools/recon/projector.py\"\n```\n\n```{python}\n#| echo : false\nbprojector = backward_projector()\nlv_volume = bprojector(proj_data_moco_par)\n```\n\n```{python}\n#| title: Reconstructed volume from projection frames with motion effect\n#| echo : false\n%%capture\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\nims = []\nfor i in range(num_moco_proj):\n    im = ax.imshow(lv_volume[i], animated=True)\n    im.axes.get_xaxis().set_visible(False)\n    im.axes.get_yaxis().set_visible(False)\n    ims.append([im])\n\nani_par_motion_vol = animation.ArtistAnimation(fig, ims, interval=50, blit=True, repeat_delay=1000)\n```\n\n```{python}\n#| echo : false\nHTML(ani_par_motion_vol.to_jshtml())\n```\n\n## Algorithms to detect and correct motion\n### 1. Optical flow\n1. Classical approach \nThis methodology is based on the assumption of *brightness constancy* , which means that the intensity of a point between consecutive frames remains the same. This can be formalized as follows\n$$I(x, y, t) - I(x + u, y + v, t + 1) = 0, $$\nwhere $w = (u, v)$ is the displacement vector between the frames. This leads to an underdetermined system of equations, needing further constraints to overcome the [aperture problem](https://en.wikipedia.org/wiki/Motion_perception#The_aperture_problem).\n\n2. Regularized models\nThere can be various techniques to regularize the aperture problem, where most naturally the *smoothness* constraint can be posed, where one can optimize the following [functional](https://en.wikipedia.org/wiki/Functional_(mathematics))\n$$E = \\iint_{\\Omega} \\Psi(I(x + u, y + v, t + 1) - I(x, y, t)) + \\alpha \\Psi(|\\nabla u|) + \\alpha \\Psi(|\\nabla v|) dx dy,$$\nwhere $\\Omega$ is the extent of the entire image $I(x, y, t)$, $\\nabla$ is the nabla (gradient) operator, $\\alpha$ is a constant and $\\Psi(.)$ is a loss function. One approach to solve this optimization problem to use the [calculus of variations](https://en.wikipedia.org/wiki/Calculus_of_variations) to compute the first variation and as a result get a necessary condition for the extremum. The *BCC* can be approximated by the [Taylor series](https://en.wikipedia.org/wiki/Taylor_series) expansion, more specifically \n$$\\frac{\\delta I}{\\delta x}u + \\frac{\\delta I}{\\delta y}v + \\frac{\\delta I}{\\delta t} = 0$$, wherewith the optimization problem can be rewritten as \n$$E = \\iint_{\\Omega} \\Psi(I_{x}u + I_{y}v + I_{t}) + \\alpha \\Psi(|\\nabla u|) + \\alpha \\Psi(|\\nabla v|) dx dy.$$\n\n3. Parametric models\nInstead of posing regularity constraints point-by-point on the pixels of the projection frames, one can group pixels into regions and estimate the motion of the regions themselves. This way one assumes that the motion can be estimated by a set of parameters, therefore the model looks as follows\n$$\\hat{\\alpha}= \\underset{\\alpha}{\\operatorname{argmin}} \\sum_{(x,y)\\in R} g(x, y) \\rho(x, y, I_{1}, I_{2}, u_{\\alpha}, v_{\\alpha}),$$\nwhere $\\alpha$ is the set of parameters determining the motion of the region $R()$, data cost term is $\\rho()$, $g()$ is the weighting funtion that determines the influence of pixel $(x, y)$ on the total cost, where $I_{1}$ and $I_{2}$ are the consecutive frames.\n\n### 2. Metamorphosis\n\n### 3. Correction during reconstruction"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"a_moco.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","title":"Motion phenomena and correction in SPECT"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}